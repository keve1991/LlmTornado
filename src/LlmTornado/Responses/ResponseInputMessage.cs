using System;
using System.Collections.Generic;
using System.Linq;
using LlmTornado.Chat;
using LlmTornado.Code;
using LlmTornado.Images;
using LlmTornado.Threads;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace LlmTornado.Responses;

/// <summary>
/// Base class for input items
/// </summary>
[JsonConverter(typeof(InputItemJsonConverter))]
public abstract class ResponseInputItem : IResponsesConversationItem
{
    /// <summary>
    /// The type of the input item
    /// </summary>
    [JsonProperty("type")]
    public abstract string Type { get; }
}

/// <summary>
/// Responses items that can be stored in conversations.
/// </summary>
public interface IResponsesConversationItem
{
    
}

/// <summary>
/// A message input to the model with a role indicating instruction following hierarchy. Instructions given with the <c>developer</c> or <c>system</c> role take precedence over instructions given with the <c>user</c> role.<br/>
/// Message contain one or more <see cref="Content"/> parts.
/// </summary>
[JsonConverter(typeof(InputItemJsonConverter))]
public class ResponseInputMessage : ResponseInputItem
{
    /// <summary>
    /// The type of the message input. Always "message".
    /// </summary>
    public override string Type => "message";

    /// <summary>
    /// The role of the message input. One of <c>user</c>, <c>system</c>, or <c>developer</c>.
    /// </summary>
    [JsonProperty("role")]
    public ChatMessageRoles Role { get; set; } = ChatMessageRoles.User;

    /// <summary>
    /// The status of item. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>. Populated when items are returned via API.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses? Status { get; set; }

    /// <summary>
    /// A list of one or many input items to the model, containing different content types.
    /// </summary>
    [JsonProperty("content")]
    public List<ResponseInputContent> Content { get; set; } = [];

    /// <summary>
    /// Creates a new empty message.
    /// </summary>
    public ResponseInputMessage()
    {
        
    }

    public ResponseInputMessage(ChatMessageRoles role, List<ResponseInputContent> content)
    {
        Role = role;
        Content = content;
    }

    public ResponseInputMessage(ChatMessageRoles role, string text)
    {
        Role = role;
        Content = [
            new ResponseInputContentText(text)
        ];
    }
}

/// <summary>
/// An internal identifier for an item to reference.
/// </summary>
public class ItemReferenceParam : ResponseInputItem
{
    /// <summary>
    /// The type of item to reference. Always "item_reference".
    /// </summary>
    public override string Type => "item_reference";

    /// <summary>
    /// The ID of the item to reference.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    public ItemReferenceParam()
    {
        
    }

    public ItemReferenceParam(string id)
    {
        Id = id;
    }
}

/// <summary>
/// The output of a function tool call.
/// </summary>
public class FunctionToolCallOutput : ResponseInputItem
{
    /// <summary>
    /// The type of the function tool call output. Always "function_call_output".
    /// </summary>
    public override string Type => "function_call_output";

    /// <summary>
    /// The unique ID of the function tool call generated by the model.
    /// </summary>
    [JsonProperty("call_id")]
    public string CallId { get; set; } = string.Empty;

    /// <summary>
    /// A JSON string of the output of the function tool call.
    /// </summary>
    [JsonProperty("output")]
    public string Output { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the function tool call output. Populated when this item is returned via API.
    /// </summary>
    [JsonProperty("id")]
    public string? Id { get; set; }

    /// <summary>
    /// The status of the item. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>. Populated when items are returned via API.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses? Status { get; set; }

    public FunctionToolCallOutput() { }

    public FunctionToolCallOutput(string callId, string output)
    {
        CallId = callId;
        Output = output;
    }
}

/// <summary>
/// The output of a computer tool call.
/// </summary>
public class ComputerToolCallOutput : ResponseInputItem
{
    /// <summary>
    /// The type of the computer tool call output. Always "computer_call_output".
    /// </summary>
    public override string Type => "computer_call_output";

    /// <summary>
    /// The ID of the computer tool call that produced the output.
    /// </summary>
    [JsonProperty("call_id")]
    public string CallId { get; set; } = string.Empty;

    /// <summary>
    /// A computer screenshot image used with the computer use tool.
    /// </summary>
    [JsonProperty("output")]
    public ComputerScreenshot Output { get; set; } = new ComputerScreenshot();

    /// <summary>
    /// The safety checks reported by the API that have been acknowledged by the developer.
    /// </summary>
    [JsonProperty("acknowledged_safety_checks")]
    public List<AcknowledgedSafetyCheck>? AcknowledgedSafetyChecks { get; set; }

    /// <summary>
    /// The ID of the computer tool call output.
    /// </summary>
    [JsonProperty("id")]
    public string? Id { get; set; }

    /// <summary>
    /// The status of the message input. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>. Populated when input items are returned via API.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses? Status { get; set; }

    public ComputerToolCallOutput() { }

    public ComputerToolCallOutput(string callId, ComputerScreenshot output)
    {
        CallId = callId;
        Output = output;
    }
}

/// <summary>
/// A computer screenshot image used with the computer use tool.
/// </summary>
public class ComputerScreenshot
{
    /// <summary>
    /// Specifies the event type. For a computer screenshot, this property is always set to "computer_screenshot".
    /// </summary>
    [JsonProperty("type")]
    public string Type { get; set; } = "computer_screenshot";

    /// <summary>
    /// The identifier of an uploaded file that contains the screenshot.
    /// </summary>
    [JsonProperty("file_id")]
    public string? FileId { get; set; }

    /// <summary>
    /// The URL of the screenshot image.
    /// </summary>
    [JsonProperty("image_url")]
    public string? ImageUrl { get; set; }
}

/// <summary>
/// Acknowledged safety check.
/// </summary>
public class AcknowledgedSafetyCheck
{
    /// <summary>
    /// The ID of the pending safety check.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The type of the pending safety check.
    /// </summary>
    [JsonProperty("code")]
    public string? Code { get; set; }

    /// <summary>
    /// Details about the pending safety check.
    /// </summary>
    [JsonProperty("message")]
    public string? Message { get; set; }
}

/// <summary>
/// The output of a local shell tool call.
/// </summary>
public class LocalShellCallOutput : ResponseInputItem
{
    /// <summary>
    /// The type of the local shell tool call output. Always "local_shell_call_output".
    /// </summary>
    public override string Type => "local_shell_call_output";

    /// <summary>
    /// The unique ID of the local shell tool call generated by the model.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// A JSON string of the output of the local shell tool call.
    /// </summary>
    [JsonProperty("output")]
    public string Output { get; set; } = string.Empty;

    /// <summary>
    /// The status of the item. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses? Status { get; set; }

    public LocalShellCallOutput() { }

    public LocalShellCallOutput(string id, string output)
    {
        Id = id;
        Output = output;
    }
}

/// <summary>
/// A response to an MCP approval request.
/// </summary>
public class McpApprovalResponse : ResponseInputItem
{
    /// <summary>
    /// The type of the item. Always "mcp_approval_response".
    /// </summary>
    public override string Type => "mcp_approval_response";

    /// <summary>
    /// The ID of the approval request being answered.
    /// </summary>
    [JsonProperty("approval_request_id")]
    public string ApprovalRequestId { get; set; } = string.Empty;

    /// <summary>
    /// Whether the request was approved.
    /// </summary>
    [JsonProperty("approve")]
    public bool Approve { get; set; }

    /// <summary>
    /// The unique ID of the approval response.
    /// </summary>
    [JsonProperty("id")]
    public string? Id { get; set; }

    /// <summary>
    /// Optional reason for the decision.
    /// </summary>
    [JsonProperty("reason")]
    public string? Reason { get; set; }

    public McpApprovalResponse() { }

    public McpApprovalResponse(string approvalRequestId, bool approve)
    {
        ApprovalRequestId = approvalRequestId;
        Approve = approve;
    }
}

/// <summary>
/// An output message from the model.
/// </summary>
public class OutputMessageInput : ResponseInputItem
{
    /// <summary>
    /// The type of the output message. Always "message".
    /// </summary>
    public override string Type => "message";

    /// <summary>
    /// The content of the output message.
    /// </summary>
    [JsonProperty("content")]
    public List<IResponseOutputContent> Content { get; set; } = [];

    /// <summary>
    /// The unique ID of the output message.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The role of the output message. Always "assistant".
    /// </summary>
    [JsonProperty("role")]
    public string Role { get; set; } = "assistant";

    /// <summary>
    /// The status of the message input. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>. Populated when input items are returned via API.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses? Status { get; set; }

    public OutputMessageInput() { }

    public OutputMessageInput(string id, List<IResponseOutputContent> content, ResponseMessageStatuses status)
    {
        Id = id;
        Content = content;
        Status = status;
    }
}

/// <summary>
/// The results of a file search tool call. See the file search guide for more information.
/// </summary>
public class FileSearchToolCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the file search tool call. Always "file_search_call".
    /// </summary>
    public override string Type => "file_search_call";

    /// <summary>
    /// The unique ID of the file search tool call.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The queries used to search for files.
    /// </summary>
    [JsonProperty("queries")]
    public List<string> Queries { get; set; } = [];

    /// <summary>
    /// The status of the file search tool call. One of <c>in_progress</c>, <c>searching</c>, <c>incomplete</c> or <c>failed</c>.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses Status { get; set; }

    /// <summary>
    /// The results of the file search tool call.
    /// </summary>
    [JsonProperty("results")]
    public List<ResponseFileSearchToolCallItemResult>? Results { get; set; }

    public FileSearchToolCallInput() { }

    public FileSearchToolCallInput(string id, List<string> queries, ResponseMessageStatuses status)
    {
        Id = id;
        Queries = queries;
        Status = status;
    }
}

/// <summary>
/// File search result.
/// </summary>
public class ResponseFileSearchToolCallItemResult
{
    /// <summary>
    /// Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard. Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters, booleans, or numbers.
    /// </summary>
    [JsonProperty("attributes")]
    public Dictionary<string, object>? Attributes { get; set; }

    /// <summary>
    /// The unique ID of the file.
    /// </summary>
    [JsonProperty("file_id")]
    public string? FileId { get; set; }

    /// <summary>
    /// The name of the file.
    /// </summary>
    [JsonProperty("filename")]
    public string? Filename { get; set; }

    /// <summary>
    /// The relevance score of the file - a value between 0 and 1.
    /// </summary>
    [JsonProperty("score")]
    public double? Score { get; set; }

    /// <summary>
    /// The text that was retrieved from the file.
    /// </summary>
    [JsonProperty("text")]
    public string? Text { get; set; }
}

/// <summary>
/// A tool call to a computer use tool. See the computer use guide for more information.
/// </summary>
public class ComputerToolCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the computer call. Always "computer_call".
    /// </summary>
    public override string Type => "computer_call";

    /// <summary>
    /// The computer action being performed.
    /// </summary>
    [JsonProperty("action")]
    public IComputerAction Action { get; set; } = new ScreenshotAction();

    /// <summary>
    /// An identifier used when responding to the tool call with output.
    /// </summary>
    [JsonProperty("call_id")]
    public string CallId { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the computer call.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The pending safety checks for the computer call.
    /// </summary>
    [JsonProperty("pending_safety_checks")]
    public List<PendingSafetyCheck> PendingSafetyChecks { get; set; } = [];

    /// <summary>
    /// The status of the item. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>. Populated when items are returned via API.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses Status { get; set; }

    public ComputerToolCallInput() { }

    public ComputerToolCallInput(string id, string callId, IComputerAction action, ResponseMessageStatuses status)
    {
        Id = id;
        CallId = callId;
        Action = action;
        Status = status;
    }
}

/// <summary>
/// Pending safety check for computer tool call.
/// </summary>
public class PendingSafetyCheck
{
    /// <summary>
    /// The type of the pending safety check.
    /// </summary>
    [JsonProperty("code")]
    public string Code { get; set; } = string.Empty;

    /// <summary>
    /// The ID of the pending safety check.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Details about the pending safety check.
    /// </summary>
    [JsonProperty("message")]
    public string Message { get; set; } = string.Empty;
}

/// <summary>
/// A tool call to run a function. See the function calling guide for more information.
/// </summary>
public class FunctionToolCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the function tool call. Always "function_call".
    /// </summary>
    public override string Type => "function_call";

    /// <summary>
    /// A JSON string of the arguments to pass to the function.
    /// </summary>
    [JsonProperty("arguments")]
    public string Arguments { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the function tool call generated by the model.
    /// </summary>
    [JsonProperty("call_id")]
    public string CallId { get; set; } = string.Empty;

    /// <summary>
    /// The name of the function to run.
    /// </summary>
    [JsonProperty("name")]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the function tool call.
    /// </summary>
    [JsonProperty("id")]
    public string? Id { get; set; }

    /// <summary>
    /// The status of the item. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>. Populated when items are returned via API.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses? Status { get; set; }

    public FunctionToolCallInput() { }

    public FunctionToolCallInput(string callId, string name, string arguments)
    {
        CallId = callId;
        Name = name;
        Arguments = arguments;
    }
}

/// <summary>
/// A description of the chain of thought used by a reasoning model while generating a response. Be sure to include these items in your input to the Responses API for subsequent turns of a conversation if you are manually managing context.
/// </summary>
public class Reasoning : ResponseInputItem
{
    /// <summary>
    /// The type of the object. Always "reasoning".
    /// </summary>
    public override string Type => "reasoning";

    /// <summary>
    /// The unique identifier of the reasoning content.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// Reasoning text contents.
    /// </summary>
    [JsonProperty("summary")]
    public List<ReasoningSummaryText> Summary { get; set; } = [];

    /// <summary>
    /// The encrypted content of the reasoning item - populated when a response is generated with reasoning.encrypted_content in the include parameter.
    /// </summary>
    [JsonProperty("encrypted_content")]
    public string? EncryptedContent { get; set; }

    /// <summary>
    /// The status of the item. One of <c>in_progress</c>, <c>completed</c>, or <c>incomplete</c>. Populated when items are returned via API.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses? Status { get; set; }

    public Reasoning() { }

    public Reasoning(string id, List<ReasoningSummaryText> summary)
    {
        Id = id;
        Summary = summary;
    }
}

/// <summary>
/// Reasoning summary text content.
/// </summary>
public class ReasoningSummaryText
{
    /// <summary>
    /// A short summary of the reasoning used by the model when generating the response.
    /// </summary>
    [JsonProperty("text")]
    public string Text { get; set; } = string.Empty;

    /// <summary>
    /// The type of the object. Always "summary_text".
    /// </summary>
    [JsonProperty("type")]
    public string Type { get; set; } = "summary_text";
}

/// <summary>
/// The results of a web search tool call. See the web search guide for more information.
/// </summary>
public class WebSearchToolCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the web search tool call. Always "web_search_call".
    /// </summary>
    public override string Type => "web_search_call";

    /// <summary>
    /// An object describing the specific action taken in this web search call. Includes details on how the model used the web (search, open_page, find).
    /// </summary>
    [JsonProperty("action")]
    public IWebSearchAction Action { get; set; } = new WebSearchActionSearch();

    /// <summary>
    /// The unique ID of the web search tool call.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The status of the web search tool call.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses Status { get; set; }

    public WebSearchToolCallInput() { }

    public WebSearchToolCallInput(string id, IWebSearchAction action, ResponseMessageStatuses status)
    {
        Id = id;
        Action = action;
        Status = status;
    }
}

/// <summary>
/// An image generation request made by the model.
/// </summary>
public class ImageGenerationCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the image generation call. Always "image_generation_call".
    /// </summary>
    public override string Type => "image_generation_call";

    /// <summary>
    /// The unique ID of the image generation call.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The generated image encoded in base64.
    /// </summary>
    [JsonProperty("result")]
    public string? Result { get; set; }

    /// <summary>
    /// The status of the image generation call.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses Status { get; set; }

    public ImageGenerationCallInput() { }

    public ImageGenerationCallInput(string id, ResponseMessageStatuses status)
    {
        Id = id;
        Status = status;
    }
}

/// <summary>
/// A tool call to run code.
/// </summary>
public class CodeInterpreterToolCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the code interpreter tool call. Always "code_interpreter_call".
    /// </summary>
    public override string Type => "code_interpreter_call";

    /// <summary>
    /// The code to run, or null if not available.
    /// </summary>
    [JsonProperty("code")]
    public string? Code { get; set; }

    /// <summary>
    /// The ID of the container used to run the code.
    /// </summary>
    [JsonProperty("container_id")]
    public string ContainerId { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the code interpreter tool call.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The outputs generated by the code interpreter, such as logs or images. Can be null if no outputs are available.
    /// </summary>
    [JsonProperty("outputs")]
    public List<ICodeInterpreterOutput>? Outputs { get; set; }

    /// <summary>
    /// The status of the code interpreter tool call.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses Status { get; set; }

    public CodeInterpreterToolCallInput() { }

    public CodeInterpreterToolCallInput(string id, string containerId, ResponseMessageStatuses status)
    {
        Id = id;
        ContainerId = containerId;
        Status = status;
    }
}

/// <summary>
/// A tool call to run a command on the local shell.
/// </summary>
public class LocalShellCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the local shell call. Always "local_shell_call".
    /// </summary>
    public override string Type => "local_shell_call";

    /// <summary>
    /// Execute a shell command on the server.
    /// </summary>
    [JsonProperty("action")]
    public LocalShellExecAction Action { get; set; } = new LocalShellExecAction();

    /// <summary>
    /// The unique ID of the local shell tool call generated by the model.
    /// </summary>
    [JsonProperty("call_id")]
    public string CallId { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the local shell call.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The status of the local shell call.
    /// </summary>
    [JsonProperty("status")]
    public ResponseMessageStatuses Status { get; set; }

    public LocalShellCallInput() { }

    public LocalShellCallInput(string id, string callId, LocalShellExecAction action, ResponseMessageStatuses status)
    {
        Id = id;
        CallId = callId;
        Action = action;
        Status = status;
    }
}

/// <summary>
/// A list of tools available on an MCP server.
/// </summary>
public class McpListToolsInput : ResponseInputItem
{
    /// <summary>
    /// The type of the item. Always "mcp_list_tools".
    /// </summary>
    public override string Type => "mcp_list_tools";

    /// <summary>
    /// The unique ID of the list.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The label of the MCP server.
    /// </summary>
    [JsonProperty("server_label")]
    public string ServerLabel { get; set; } = string.Empty;

    /// <summary>
    /// The tools available on the server.
    /// </summary>
    [JsonProperty("tools")]
    public List<McpTool> Tools { get; set; } = [];

    /// <summary>
    /// Error message if the server could not list tools.
    /// </summary>
    [JsonProperty("error")]
    public string? Error { get; set; }

    public McpListToolsInput() { }

    public McpListToolsInput(string id, string serverLabel, List<McpTool> tools)
    {
        Id = id;
        ServerLabel = serverLabel;
        Tools = tools;
    }
}

/// <summary>
/// MCP tool definition.
/// </summary>
public class McpTool
{
    /// <summary>
    /// The JSON schema describing the tool's input.
    /// </summary>
    [JsonProperty("input_schema")]
    public object InputSchema { get; set; } = new object();

    /// <summary>
    /// The name of the tool.
    /// </summary>
    [JsonProperty("name")]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// Additional annotations about the tool.
    /// </summary>
    [JsonProperty("annotations")]
    public object? Annotations { get; set; }

    /// <summary>
    /// The description of the tool.
    /// </summary>
    [JsonProperty("description")]
    public string? Description { get; set; }
}

/// <summary>
/// A request for human approval of a tool invocation.
/// </summary>
public class McpApprovalRequestInput : ResponseInputItem
{
    /// <summary>
    /// The type of the item. Always "mcp_approval_request".
    /// </summary>
    public override string Type => "mcp_approval_request";

    /// <summary>
    /// A JSON string of arguments for the tool.
    /// </summary>
    [JsonProperty("arguments")]
    public string Arguments { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the approval request.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The name of the tool to run.
    /// </summary>
    [JsonProperty("name")]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// The label of the MCP server making the request.
    /// </summary>
    [JsonProperty("server_label")]
    public string ServerLabel { get; set; } = string.Empty;

    public McpApprovalRequestInput() { }

    public McpApprovalRequestInput(string id, string name, string serverLabel, string arguments)
    {
        Id = id;
        Name = name;
        ServerLabel = serverLabel;
        Arguments = arguments;
    }
}

/// <summary>
/// An invocation of a tool on an MCP server.
/// </summary>
public class McpToolCallInput : ResponseInputItem
{
    /// <summary>
    /// The type of the item. Always "mcp_call".
    /// </summary>
    public override string Type => "mcp_call";

    /// <summary>
    /// A JSON string of the arguments passed to the tool.
    /// </summary>
    [JsonProperty("arguments")]
    public string Arguments { get; set; } = string.Empty;

    /// <summary>
    /// The unique ID of the tool call.
    /// </summary>
    [JsonProperty("id")]
    public string Id { get; set; } = string.Empty;

    /// <summary>
    /// The name of the tool that was run.
    /// </summary>
    [JsonProperty("name")]
    public string Name { get; set; } = string.Empty;

    /// <summary>
    /// The label of the MCP server running the tool.
    /// </summary>
    [JsonProperty("server_label")]
    public string ServerLabel { get; set; } = string.Empty;

    /// <summary>
    /// The error from the tool call, if any.
    /// </summary>
    [JsonProperty("error")]
    public string? Error { get; set; }

    /// <summary>
    /// The output from the tool call.
    /// </summary>
    [JsonProperty("output")]
    public string? Output { get; set; }

    public McpToolCallInput() { }

    public McpToolCallInput(string id, string name, string serverLabel, string arguments)
    {
        Id = id;
        Name = name;
        ServerLabel = serverLabel;
        Arguments = arguments;
    }
}

/// <summary>
/// JSON converter for InputItem types
/// </summary>
internal class InputItemJsonConverter : JsonConverter<ResponseInputItem>
{
    public override void WriteJson(JsonWriter writer, ResponseInputItem? value, JsonSerializer serializer)
    {
        if (value is null)
        {
            writer.WriteNull();
            return;
        }

        writer.WriteStartObject();
        writer.WritePropertyName("type");
        writer.WriteValue(value.Type);

        switch (value)
        {
            case ResponseInputMessage msg:
            {
                writer.WritePropertyName("role");
                serializer.Serialize(writer, msg.Role);
                writer.WritePropertyName("content");
                serializer.Serialize(writer, msg.Content);
                
                if (msg.Status != null)
                {
                    writer.WritePropertyName("status");
                    serializer.Serialize(writer, msg.Status);
                }
                
                break;
            }
            case ItemReferenceParam refParam:
            {
                writer.WritePropertyName("id");
                writer.WriteValue(refParam.Id);
                break;
            }
            case FunctionToolCallOutput funcOutput:
            {
                writer.WritePropertyName("call_id");
                writer.WriteValue(funcOutput.CallId);
                writer.WritePropertyName("output");
                writer.WriteValue(funcOutput.Output);
                
                if (funcOutput.Id is { Length: > 0 })
                {
                    writer.WritePropertyName("id");
                    writer.WriteValue(funcOutput.Id);
                }
                
                if (funcOutput.Status != null)
                {
                    writer.WritePropertyName("status");
                    serializer.Serialize(writer, funcOutput.Status);
                }
                break;
            }
            case ComputerToolCallOutput compOutput:
            {
                writer.WritePropertyName("call_id");
                writer.WriteValue(compOutput.CallId);
                writer.WritePropertyName("output");
                serializer.Serialize(writer, compOutput.Output);
                
                if (compOutput.AcknowledgedSafetyChecks != null)
                {
                    writer.WritePropertyName("acknowledged_safety_checks");
                    serializer.Serialize(writer, compOutput.AcknowledgedSafetyChecks);
                }
                
                if (compOutput.Id is { Length: > 0 })
                {
                    writer.WritePropertyName("id");
                    writer.WriteValue(compOutput.Id);
                }
                
                if (compOutput.Status != null)
                {
                    writer.WritePropertyName("status");
                    serializer.Serialize(writer, compOutput.Status);
                }
                break;
            }
            case LocalShellCallOutput shellOutput:
            {
                writer.WritePropertyName("id");
                writer.WriteValue(shellOutput.Id);
                writer.WritePropertyName("output");
                writer.WriteValue(shellOutput.Output);
                
                if (shellOutput.Status != null)
                {
                    writer.WritePropertyName("status");
                    serializer.Serialize(writer, shellOutput.Status);
                }
                break;
            }
            case McpApprovalResponse mcpResponse:
            {
                writer.WritePropertyName("approval_request_id");
                writer.WriteValue(mcpResponse.ApprovalRequestId);
                writer.WritePropertyName("approve");
                writer.WriteValue(mcpResponse.Approve);
                
                if (mcpResponse.Id is { Length: > 0 })
                {
                    writer.WritePropertyName("id");
                    writer.WriteValue(mcpResponse.Id);
                }
                
                if (mcpResponse.Reason != null)
                {
                    writer.WritePropertyName("reason");
                    writer.WriteValue(mcpResponse.Reason);
                }
                
                break;
            }
            case OutputMessageInput outputMessage:
            {
                writer.WritePropertyName("content");
                serializer.Serialize(writer, outputMessage.Content);

                if (outputMessage.Id is { Length: > 0 })
                {
                    writer.WritePropertyName("id");
                    writer.WriteValue(outputMessage.Id);    
                }
                
                writer.WritePropertyName("role");
                writer.WriteValue(outputMessage.Role);

                if (outputMessage.Status is not null)
                {
                    writer.WritePropertyName("status");
                    writer.WriteValue(outputMessage.Status);    
                }
                
                break;
            }
            case FileSearchToolCallInput fileSearchToolCall:
            {
                writer.WritePropertyName("id");
                writer.WriteValue(fileSearchToolCall.Id);
                writer.WritePropertyName("queries");
                serializer.Serialize(writer, fileSearchToolCall.Queries);
                writer.WritePropertyName("status");
                writer.WriteValue(fileSearchToolCall.Status);
                if (fileSearchToolCall.Results != null)
                {
                    writer.WritePropertyName("results");
                    serializer.Serialize(writer, fileSearchToolCall.Results);
                }
                break;
            }
            case ComputerToolCallInput computerToolCall:
            {
                writer.WritePropertyName("action");
                serializer.Serialize(writer, computerToolCall.Action);
                writer.WritePropertyName("call_id");
                writer.WriteValue(computerToolCall.CallId);
                writer.WritePropertyName("id");
                writer.WriteValue(computerToolCall.Id);
                writer.WritePropertyName("pending_safety_checks");
                serializer.Serialize(writer, computerToolCall.PendingSafetyChecks);
                writer.WritePropertyName("status");
                writer.WriteValue(computerToolCall.Status);
                break;
            }
            case FunctionToolCallInput functionToolCall:
            {
                writer.WritePropertyName("arguments");
                writer.WriteValue(functionToolCall.Arguments);
                writer.WritePropertyName("call_id");
                writer.WriteValue(functionToolCall.CallId);
                writer.WritePropertyName("name");
                writer.WriteValue(functionToolCall.Name);
                
                if (functionToolCall.Id is { Length: > 0 })
                {
                    writer.WritePropertyName("id");
                    writer.WriteValue(functionToolCall.Id);
                }
                
                if (functionToolCall.Status is not null)
                {
                    writer.WritePropertyName("status");
                    writer.WriteValue(functionToolCall.Status);
                }
                
                break;
            }
            case Reasoning reasoning:
            {
                writer.WritePropertyName("id");
                writer.WriteValue(reasoning.Id);
                writer.WritePropertyName("summary");
                serializer.Serialize(writer, reasoning.Summary);
                
                if (reasoning.EncryptedContent != null)
                {
                    writer.WritePropertyName("encrypted_content");
                    writer.WriteValue(reasoning.EncryptedContent);
                }
                
                if (reasoning.Status != null)
                {
                    writer.WritePropertyName("status");
                    writer.WriteValue(reasoning.Status);
                }
                break;
            }
            case WebSearchToolCallInput webSearchToolCall:
            {
                writer.WritePropertyName("action");
                serializer.Serialize(writer, webSearchToolCall.Action);
                writer.WritePropertyName("id");
                writer.WriteValue(webSearchToolCall.Id);
                writer.WritePropertyName("status");
                writer.WriteValue(webSearchToolCall.Status);
                break;
            }
            case ImageGenerationCallInput imageGenerationCall:
            {
                writer.WritePropertyName("id");
                writer.WriteValue(imageGenerationCall.Id);
                writer.WritePropertyName("result");
                writer.WriteValue(imageGenerationCall.Result);
                writer.WritePropertyName("status");
                writer.WriteValue(imageGenerationCall.Status);
                break;
            }
            case CodeInterpreterToolCallInput codeInterpreterCall:
            {
                writer.WritePropertyName("code");
                writer.WriteValue(codeInterpreterCall.Code);
                writer.WritePropertyName("container_id");
                writer.WriteValue(codeInterpreterCall.ContainerId);
                writer.WritePropertyName("id");
                writer.WriteValue(codeInterpreterCall.Id);
                writer.WritePropertyName("outputs");
                serializer.Serialize(writer, codeInterpreterCall.Outputs);
                writer.WritePropertyName("status");
                writer.WriteValue(codeInterpreterCall.Status);
                break;
            }
            case LocalShellCallInput localShellCall:
            {
                writer.WritePropertyName("action");
                serializer.Serialize(writer, localShellCall.Action);
                writer.WritePropertyName("call_id");
                writer.WriteValue(localShellCall.CallId);
                writer.WritePropertyName("id");
                writer.WriteValue(localShellCall.Id);
                writer.WritePropertyName("status");
                writer.WriteValue(localShellCall.Status);
                break;
            }
            case McpListToolsInput mcpListTools:
            {
                writer.WritePropertyName("id");
                writer.WriteValue(mcpListTools.Id);
                writer.WritePropertyName("server_label");
                writer.WriteValue(mcpListTools.ServerLabel);
                writer.WritePropertyName("tools");
                serializer.Serialize(writer, mcpListTools.Tools);
                if (mcpListTools.Error != null)
                {
                    writer.WritePropertyName("error");
                    writer.WriteValue(mcpListTools.Error);
                }
                break;
            }
            case McpApprovalRequestInput mcpApprovalRequest:
            {
                writer.WritePropertyName("arguments");
                writer.WriteValue(mcpApprovalRequest.Arguments);
                writer.WritePropertyName("id");
                writer.WriteValue(mcpApprovalRequest.Id);
                writer.WritePropertyName("name");
                writer.WriteValue(mcpApprovalRequest.Name);
                writer.WritePropertyName("server_label");
                writer.WriteValue(mcpApprovalRequest.ServerLabel);
                break;
            }
            case McpToolCallInput mcpToolCall:
            {
                writer.WritePropertyName("arguments");
                writer.WriteValue(mcpToolCall.Arguments);
                writer.WritePropertyName("id");
                writer.WriteValue(mcpToolCall.Id);
                writer.WritePropertyName("name");
                writer.WriteValue(mcpToolCall.Name);
                writer.WritePropertyName("server_label");
                writer.WriteValue(mcpToolCall.ServerLabel);
                if (mcpToolCall.Error != null)
                {
                    writer.WritePropertyName("error");
                    writer.WriteValue(mcpToolCall.Error);
                }
                if (mcpToolCall.Output != null)
                {
                    writer.WritePropertyName("output");
                    writer.WriteValue(mcpToolCall.Output);
                }
                break;
            }
            default:
            {
                throw new JsonSerializationException($"Unknown InputItem type: {value.GetType()}");
            }
        }

        writer.WriteEndObject();
    }

    public override ResponseInputItem? ReadJson(JsonReader reader, Type objectType, ResponseInputItem? existingValue, bool hasExistingValue, JsonSerializer serializer)
    {
        if (reader.TokenType is JsonToken.Null)
        {
            return null;
        }

        JObject jo = JObject.Load(reader);
        string? type = jo["type"]?.ToString();

        return type switch
        {
            "message" when IsOutputMessage(jo) => DeserializeOutputMessage(jo, serializer),
            "message" => DeserializeMessage(jo, serializer),
            "item_reference" => DeserializeItemReference(jo, serializer),
            "function_call_output" => DeserializeFunctionCallOutput(jo, serializer),
            "computer_call_output" => DeserializeComputerCallOutput(jo, serializer),
            "local_shell_call_output" => DeserializeLocalShellCallOutput(jo, serializer),
            "mcp_approval_response" => DeserializeMcpApprovalResponse(jo, serializer),
            "file_search_call" => DeserializeFileSearchToolCall(jo, serializer),
            "computer_call" => DeserializeComputerToolCall(jo, serializer),
            "function_call" => DeserializeFunctionToolCall(jo, serializer),
            "reasoning" => DeserializeReasoning(jo, serializer),
            "web_search_call" => DeserializeWebSearchToolCall(jo, serializer),
            "image_generation_call" => DeserializeImageGenerationCall(jo, serializer),
            "code_interpreter_call" => DeserializeCodeInterpreterCall(jo, serializer),
            "local_shell_call" => DeserializeLocalShellCall(jo, serializer),
            "mcp_list_tools" => DeserializeMcpListTools(jo, serializer),
            "mcp_approval_request" => DeserializeMcpApprovalRequest(jo, serializer),
            "mcp_call" => DeserializeMcpToolCall(jo, serializer),
            _ => throw new JsonSerializationException($"Unknown input item type: {type}")
        };
    }

    private static bool IsOutputMessage(JObject jo)
    {
        // Check if this is an output message by looking for assistant role
        string? role = jo["role"]?.ToString();
        return role == "assistant";
    }

    private static ResponseInputMessage DeserializeMessage(JObject jo, JsonSerializer serializer)
    {
        ResponseInputMessage message = new ResponseInputMessage();

        if (jo["role"]?.ToString() is { } roleStr && Enum.TryParse(roleStr, true, out ChatMessageRoles role))
            message.Role = role;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            message.Status = status;
        
        if (jo["content"] is JArray contentArray)
        {
            message.Content = [];
            foreach (JToken? contentItem in contentArray)
            {
                if (contentItem is JObject contentObj)
                {
                    string? contentType = contentObj["type"]?.ToString();
                    ResponseInputContent? content = contentType switch
                    {
                        "input_text" => new ResponseInputContentText
                        {
                            Text = contentObj["text"]?.ToString() ?? string.Empty
                        },
                        "input_image" => new ResponseInputContentImage
                        {
                            ImageUrl = contentObj["image_url"]?.ToString(),
                            FileId = contentObj["file_id"]?.ToString(),
                            Detail = contentObj["detail"]?.ToObject<ImageDetail>()
                        },
                        "input_file" => new ResponseInputContentFile
                        {
                            FileId = contentObj["file_id"]?.ToString(),
                            Filename = contentObj["filename"]?.ToString(),
                            FileData = contentObj["file_data"]?.ToString()
                        },
                        _ => null
                    };
                    
                    if (content != null)
                        message.Content.Add(content);
                }
            }
        }
        
        return message;
    }

    private static ItemReferenceParam DeserializeItemReference(JObject jo, JsonSerializer serializer)
    {
        ItemReferenceParam item = new ItemReferenceParam();
        
        if (jo["id"]?.ToString() is { } id)
            item.Id = id;
        
        return item;
    }

    private static FunctionToolCallOutput DeserializeFunctionCallOutput(JObject jo, JsonSerializer serializer)
    {
        FunctionToolCallOutput output = new FunctionToolCallOutput();
        
        if (jo["call_id"]?.ToString() is { } callId)
            output.CallId = callId;
        
        if (jo["output"]?.ToString() is { } outputStr)
            output.Output = outputStr;
        
        if (jo["id"]?.ToString() is { } id)
            output.Id = id;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            output.Status = status;
        
        return output;
    }

    private static ComputerToolCallOutput DeserializeComputerCallOutput(JObject jo, JsonSerializer serializer)
    {
        ComputerToolCallOutput output = new ComputerToolCallOutput();
        
        if (jo["call_id"]?.ToString() is { } callId)
            output.CallId = callId;
        
        if (jo["output"] is JObject outputObj && outputObj.ToObject<ComputerScreenshot>() is { } screenshot)
            output.Output = screenshot;
        
        if (jo["id"]?.ToString() is { } id)
            output.Id = id;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            output.Status = status;
        
        if (jo["acknowledged_safety_checks"] is JArray checksArray)
        {
            output.AcknowledgedSafetyChecks = checksArray.ToObject<List<AcknowledgedSafetyCheck>>();
        }
        
        return output;
    }

    private static LocalShellCallOutput DeserializeLocalShellCallOutput(JObject jo, JsonSerializer serializer)
    {
        LocalShellCallOutput output = new LocalShellCallOutput();
        
        if (jo["id"]?.ToString() is { } id)
            output.Id = id;
        
        if (jo["output"]?.ToString() is { } outputStr)
            output.Output = outputStr;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            output.Status = status;
        
        return output;
    }

    private static McpApprovalResponse DeserializeMcpApprovalResponse(JObject jo, JsonSerializer serializer)
    {
        McpApprovalResponse response = new McpApprovalResponse();
        
        if (jo["approval_request_id"]?.ToString() is { } approvalRequestId)
            response.ApprovalRequestId = approvalRequestId;
        
        if (jo["approve"]?.ToObject<bool>() is { } approve)
            response.Approve = approve;
        
        if (jo["id"]?.ToString() is { } id)
            response.Id = id;
        
        if (jo["reason"]?.ToString() is { } reason)
            response.Reason = reason;
        
        return response;
    }

    private static OutputMessageInput DeserializeOutputMessage(JObject jo, JsonSerializer serializer)
    {
        OutputMessageInput message = new OutputMessageInput();
        
        if (jo["id"]?.ToString() is { } id)
            message.Id = id;
        
        if (jo["role"]?.ToString() is { } role)
            message.Role = role;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            message.Status = status;
        
        if (jo["content"] is JArray contentArray)
        {
            message.Content = [];
            foreach (JToken? contentItem in contentArray)
            {
                if (contentItem is JObject contentObj)
                {
                    string? contentType = contentObj["type"]?.ToString();
                    IResponseOutputContent? content = contentType switch
                    {
                        "output_text" => new ResponseOutputTextContent
                        {
                            Type = "output_text",
                            Text = contentObj["text"]?.ToString() ?? string.Empty,
                            Annotations = DeserializeAnnotations(contentObj["annotations"] as JArray),
                            Logprobs = contentObj["logprobs"]?.ToObject<List<LogProbProperties>>()
                        },
                        "refusal" => new RefusalContent
                        {
                            Type = "refusal",
                            Refusal = contentObj["refusal"]?.ToString() ?? string.Empty
                        },
                        _ => null
                    };
                    
                    if (content != null)
                        message.Content.Add(content);
                }
            }
        }
        
        return message;
    }

    private static FileSearchToolCallInput DeserializeFileSearchToolCall(JObject jo, JsonSerializer serializer)
    {
        FileSearchToolCallInput input = new FileSearchToolCallInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["queries"] is JArray queriesArray)
        {
            foreach (JToken? query in queriesArray)
            {
                if (query.ToString() is { } queryStr)
                    input.Queries.Add(queryStr);
            }
        }
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            input.Status = status;
        
        if (jo["results"] is JArray resultsArray)
        {
            input.Results = resultsArray.ToObject<List<ResponseFileSearchToolCallItemResult>>();
        }
        
        return input;
    }

    private static ComputerToolCallInput DeserializeComputerToolCall(JObject jo, JsonSerializer serializer)
    {
        ComputerToolCallInput input = new ComputerToolCallInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["call_id"]?.ToString() is { } callId)
            input.CallId = callId;
        
        if (jo["action"] is JObject actionObj && actionObj.ToObject<IComputerAction>() is { } action)
            input.Action = action;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            input.Status = status;
        
        if (jo["pending_safety_checks"] is JArray checksArray)
        {
            input.PendingSafetyChecks = checksArray.ToObject<List<PendingSafetyCheck>>() ?? [];
        }
        
        return input;
    }

    private static FunctionToolCallInput DeserializeFunctionToolCall(JObject jo, JsonSerializer serializer)
    {
        FunctionToolCallInput input = new FunctionToolCallInput();
        
        if (jo["call_id"]?.ToString() is { } callId)
            input.CallId = callId;
        
        if (jo["name"]?.ToString() is { } name)
            input.Name = name;
        
        if (jo["arguments"]?.ToString() is { } arguments)
            input.Arguments = arguments;
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            input.Status = status;
        
        return input;
    }

    private static Reasoning DeserializeReasoning(JObject jo, JsonSerializer serializer)
    {
        Reasoning reasoning = new Reasoning();
        
        if (jo["id"]?.ToString() is { } id)
            reasoning.Id = id;
        
        if (jo["summary"] is JArray summaryArray)
        {
            foreach (JToken? summaryItem in summaryArray)
            {
                if (summaryItem.ToObject<ReasoningSummaryText>() is { } summary)
                    reasoning.Summary.Add(summary);
            }
        }
        
        if (jo["encrypted_content"]?.ToString() is { } encryptedContent)
            reasoning.EncryptedContent = encryptedContent;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            reasoning.Status = status;
        
        return reasoning;
    }

    private static WebSearchToolCallInput DeserializeWebSearchToolCall(JObject jo, JsonSerializer serializer)
    {
        WebSearchToolCallInput input = new WebSearchToolCallInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["action"] is JObject actionObj && actionObj.ToObject<IWebSearchAction>() is { } action)
            input.Action = action;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            input.Status = status;
        
        return input;
    }

    private static ImageGenerationCallInput DeserializeImageGenerationCall(JObject jo, JsonSerializer serializer)
    {
        ImageGenerationCallInput input = new ImageGenerationCallInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            input.Status = status;
        
        return input;
    }

    private static CodeInterpreterToolCallInput DeserializeCodeInterpreterCall(JObject jo, JsonSerializer serializer)
    {
        CodeInterpreterToolCallInput input = new CodeInterpreterToolCallInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["container_id"]?.ToString() is { } containerId)
            input.ContainerId = containerId;
        
        if (jo["code"]?.ToString() is { } code)
            input.Code = code;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            input.Status = status;
        
        if (jo["outputs"] is JArray outputsArray)
        {
            input.Outputs = [];
            
            foreach (JToken? outputItem in outputsArray)
            {
                if (outputItem is JObject outputObj)
                {
                    string? outputType = outputObj["type"]?.ToString();
                    ICodeInterpreterOutput? output = outputType switch
                    {
                        "logs" => new CodeInterpreterOutputLogs
                        {
                            Type = "logs",
                            Logs = outputObj["logs"]?.ToString() ?? string.Empty
                        },
                        "image" => new CodeInterpreterOutputImage
                        {
                            Type = "image",
                            Url = outputObj["url"]?.ToString() ?? string.Empty
                        },
                        _ => null
                    };
                    
                    if (output != null)
                        input.Outputs.Add(output);
                }
            }
        }
        
        return input;
    }

    private static LocalShellCallInput DeserializeLocalShellCall(JObject jo, JsonSerializer serializer)
    {
        LocalShellCallInput input = new LocalShellCallInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["call_id"]?.ToString() is { } callId)
            input.CallId = callId;
        
        if (jo["action"] is JObject actionObj && actionObj.ToObject<LocalShellExecAction>() is { } action)
            input.Action = action;
        
        if (jo["status"]?.ToString() is { } statusStr && Enum.TryParse(statusStr, true, out ResponseMessageStatuses status))
            input.Status = status;
        
        return input;
    }

    private static McpListToolsInput DeserializeMcpListTools(JObject jo, JsonSerializer serializer)
    {
        McpListToolsInput input = new McpListToolsInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["server_label"]?.ToString() is { } serverLabel)
            input.ServerLabel = serverLabel;
        
        if (jo["tools"] is JArray toolsArray)
        {
            foreach (JToken? tool in toolsArray)
            {
                if (tool.ToObject<McpTool>() is { } mcpTool)
                    input.Tools.Add(mcpTool);
            }
        }
        
        if (jo["error"]?.ToString() is { } error)
            input.Error = error;
        
        return input;
    }

    private static McpApprovalRequestInput DeserializeMcpApprovalRequest(JObject jo, JsonSerializer serializer)
    {
        McpApprovalRequestInput input = new McpApprovalRequestInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["name"]?.ToString() is { } name)
            input.Name = name;
        
        if (jo["server_label"]?.ToString() is { } serverLabel)
            input.ServerLabel = serverLabel;
        
        if (jo["arguments"]?.ToString() is { } arguments)
            input.Arguments = arguments;
        
        return input;
    }

    private static McpToolCallInput DeserializeMcpToolCall(JObject jo, JsonSerializer serializer)
    {
        McpToolCallInput input = new McpToolCallInput();
        
        if (jo["id"]?.ToString() is { } id)
            input.Id = id;
        
        if (jo["name"]?.ToString() is { } name)
            input.Name = name;
        
        if (jo["server_label"]?.ToString() is { } serverLabel)
            input.ServerLabel = serverLabel;
        
        if (jo["arguments"]?.ToString() is { } arguments)
            input.Arguments = arguments;
        
        if (jo["error"]?.ToString() is { } error)
            input.Error = error;
        
        if (jo["output"]?.ToString() is { } output)
            input.Output = output;
        
        return input;
    }

    private static List<IResponseOutputContentAnnotation> DeserializeAnnotations(JArray? annotationsArray)
    {
        if (annotationsArray is null)
        {
            return [];
        }

        List<IResponseOutputContentAnnotation> annotations = [];
        foreach (JToken? annotationToken in annotationsArray)
        {
            if (annotationToken is JObject annotationObj)
            {
                string? type = annotationObj["type"]?.ToString();
                IResponseOutputContentAnnotation? annotation = type switch
                {
                    "file_citation" => new FileCitationAnnotation
                    {
                        Type = "file_citation",
                        FileId = annotationObj["file_id"]?.ToString() ?? string.Empty,
                        Index = annotationObj["index"]?.ToObject<int>() ?? 0,
                        Filename = annotationObj["filename"]?.ToString() ?? string.Empty
                    },
                    "url_citation" => new UrlCitationAnnotation
                    {
                        Type = "url_citation",
                        Url = annotationObj["url"]?.ToString() ?? string.Empty,
                        StartIndex = annotationObj["start_index"]?.ToObject<int>() ?? 0,
                        EndIndex = annotationObj["end_index"]?.ToObject<int>() ?? 0,
                        Title = annotationObj["title"]?.ToString() ?? string.Empty
                    },
                    "container_file_citation" => new ContainerFileCitationAnnotation
                    {
                        Type = "container_file_citation",
                        ContainerId = annotationObj["container_id"]?.ToString() ?? string.Empty,
                        FileId = annotationObj["file_id"]?.ToString() ?? string.Empty,
                        StartIndex = annotationObj["start_index"]?.ToObject<int>() ?? 0,
                        EndIndex = annotationObj["end_index"]?.ToObject<int>() ?? 0,
                        Filename = annotationObj["filename"]?.ToString() ?? string.Empty
                    },
                    "file_path" => new FilePathAnnotation
                    {
                        Type = "file_path",
                        FileId = annotationObj["file_id"]?.ToString() ?? string.Empty,
                        Index = annotationObj["index"]?.ToObject<int>() ?? 0
                    },
                    _ => null
                };

                if (annotation != null)
                {
                    annotations.Add(annotation);
                }
            }
        }

        return annotations;
    }
} 